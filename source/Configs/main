#!/bin/bash
hi_exit() {
	echo -e "\n${rec}Exit${noc}\n"; rm -rf "$TEMPPATH"
}

generalinput() {
	gi_name="$(echo "$1" | cut -d'|' -f1)"
	gi_default="$(echo "$1" | cut -d'|' -f2)"
	gi_end="$(echo "$1" | cut -d'|' -f3)"
	gi_file="$HISTORYPATH/.${gi_name}"
	if [[ ! -f "$gi_file" ]]; then touch "$gi_file"; fi
	history -r "$gi_file"
	if [[ "${gi_default}" == "none" ]]; then echo -e "\nEnter $2 (${cyc}q|Q${noc} for ${grc}exit${noc}):"
	else echo -e "\nEnter $2 (Default: ${grc}${gi_default}${noc}) (${cyc}d|D${noc} for ${grc}default${noc}, ${cyc}q|Q${noc} for ${grc}exit${noc}):"; fi; read -e "input_ans"
	if [[ "$input_ans" == [qQйЙ] ]]; then
		if [[ "$gi_end" != "exit" ]]; then input_ans=""; else exit; fi
	elif [[ "$input_ans" == [dDвВ] && "${gi_default}" != "none" ]]; then input_ans="${gi_default}"
	elif [[ "$input_ans" == "" ]]; then generalinput "$1" "$2"
	else
		flg=0
		while (( flg == 0 )); do
			listcount=0; flg=1
			if [[ ! -f "$gi_file" ]]; then touch "$gi_file"; fi
			while read line; do let "listcount += 1"; if [[ "$line" = "$input_ans" ]]; then flg=0; sed -i ${listcount}d "$gi_file"; break; fi
		done < "$gi_file"; done; echo "$input_ans" >> "$gi_file"; fi
	history -c 
}

addlines() {
	generalinput "$1|none|exit" "${cyc}path${noc} to the ${grc}$1${noc} folder"; line_path="$input_ans"
	if [[ ! -d "$line_path" ]]; then mkdir -p "$line_path"; fi
	echo -e "$line_path" >> "$2"
}

deletelines() {
	readfiles "$1" "$2"
	sed -i ${select_ans}d "$2"
	if [[ -d "$read_result_dir" ]]; then
		listoptions "Delete folder from filesystem?" "Yes|No" "" "" "" ""
		if [[ "$select_ans" == "1" ]]; then rm -rf "$read_result_dir"; fi; fi
	if [[ ! -s "$2" ]]; then rm "$2"; fi
}

readfiles() {
	rf_count=0
	if [[ -n "$2" ]]; then
		echo -e "\n ${mac}$1${noc}\n"
		while read line; do
			if echo "$line" | grep -qo " | "; then
				file_names[$rf_count]="$(echo "$line" | awk -F" [|] " '{print $1}')"
				file_dirs[$rf_count]="$(echo "$line" | awk -F" [|] " '{print $2}')"
				echo -e " ${cyc}$((rf_count+=1))${noc} - ${grc}$(echo "$line" | awk -F" [|] " '{print $1}')${noc} - ${blc}$(echo "$line" | awk -F" [|] " '{print $2}')${noc}"	
			else
				file_dirs[$rf_count]="$line"
				echo -e " ${cyc}$((rf_count+=1))${noc} - ${grc}${line}${noc}"; fi; done < "$2"
		echo -e "\nChoose ${cyc}item${noc} from the ${grc}list${noc} above (${cyc}q|Q${noc} for ${grc}exit${noc}):"; read -e "select_ans"
		if [[ "$select_ans" == [qQйЙ] ]]; then exit
		elif [[ "$select_ans" -ge "$((rf_count+1))" || "$select_ans" -le "0" ]]; then readfiles "$1" "$2"
		else 
			if [[ -n "${file_names:+nex}" ]]; then read_result_name="${file_names[select_ans-1]}"; fi
			read_result_dir="${file_dirs[select_ans-1]}"; fi
	else echo -e "\n${grc}File${noc} is ${rec}empty${noc}"; exit; fi
}

listoptions() {
	IFS="|"; lo_count=0; sa_count=0; da_count=0
	echo -e "\n ${mac}$1${noc}\n"
	if [[ -n "$6" ]]; then
		for item in $6; do
			desc_array[$da_count]="$item"; let "da_count+=1"; done
	else unset desc_array; fi
	for item in $4; do
		status_array[$sa_count]="$item"; let "sa_count+=1"; done
	for option in $2; do 
		if [[ -n "$4" && -n "${!status_array[lo_count]:+nex}" ]]; then
			status_check=" - ${grc}ON${noc}${cyc} ( ${!status_array[lo_count]})${noc}"
		elif [[ -n "$4" ]]; then
			status_check=" - ${rec}OFF${noc}"; else status_check=""; fi
		if [[ "$option" == "Reset Options" ]]; then status_check=""; fi
		list_array[$lo_count]="$option"
		if [[ -n "${desc_array[lo_count]:+nex}" ]]; then item_desc=" - ${blc}${desc_array[lo_count]}${noc}"; else item_desc=""; fi
		echo -e " ${cyc}$((lo_count+=1))${noc}${status_check} - ${grc}$option${noc}${item_desc}"; done; IFS="$Def_IFS"; let "lo_count+=1"
	if [[ "$2" == "Yes|No" ]]; then echo -e "\nChoose ${cyc}Option${noc} from the list above:"
	else echo -e "\nChoose ${cyc}Option${noc} from the list above (${cyc}q|Q${noc} for ${grc}exit${noc}):"; fi
	read -e "select_ans"
	if [[ "$select_ans" == [qQйЙ] && "$2" != "Yes|No" ]]; then
		if [[ -z "$3" ]]; then exit; fi
	elif [[ "$select_ans" == [a-zA-Z] ]]; then
		listoptions "$1" "$2" "$3" "$4" "$5" "$6"
	elif [[ "$select_ans" -ge "$lo_count" || "$select_ans" -le "0" ]]; then
		listoptions "$1" "$2" "$3" "$4" "$5" "$6"
	else if [[ -n "$3" ]]; then
		${3}selector "${list_array[select_ans-1]}" "$5"; listoptions "$1" "$2" "$3" "$4" "$5" "$6"; fi; fi; 
}

git-latest() {
  	git_version=$(curl --silent "https://api.github.com/repos/$1/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
	wget "https://github.com/$1/releases/download/${git_version}/$2"
}
